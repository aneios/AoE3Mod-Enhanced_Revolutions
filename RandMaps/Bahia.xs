/*
Bahia (formerly Lumaco)
map by Rikkikipu
ported to DE by vividlyplain, September 2021
Map file generated by jsrms tool
Generation Date: Tue May 26 00:14:39 +0200 2020
*/

include "mercenaries.xs";
include "ypAsianInclude.xs";
include "ypKOTHInclude.xs";

int i = 0;
int j = 0;
int k = 0;

void main (void) {

string baseTerrainType = "araucania_north_dirt_a";
string impDirt = "bayou\ground4_bay";
string waterType = "Araucania North Coast";
string cliffType = "Araucania North Coast";
string forestType = "North Araucania Forest";
string mineType = "mine";
string huntType = "Tapir";
string subCiv = "Jesuit";
string nativeVillage = "native jesuit mission borneo 0";
string lightingSet = "rm_Bahia";
string treeType = "TreeAraucania";
float TeamNum = cNumberTeams;
float PlayerNum = cNumberNonGaiaPlayers;
float numPlayer = cNumberPlayers;
rmSetStatusText("", 0.01);
float playerTiles = 7000;
if ((PlayerNum == 2 && rmGetIsTreaty() == true)) {
	playerTiles=10000;
}

if ((PlayerNum >= 4)) {
	playerTiles=6800;
}

if ((PlayerNum >= 6)) {
	playerTiles=6500;
}

if ((PlayerNum == 8)) {
	playerTiles=7500;
}

float size = (2 * sqrt((PlayerNum * playerTiles)));
float longside = (1.6 * size);
rmEchoInfo((((("Map size=" + size) + "m x ") + size) + "m"));
rmSetMapSize(longside, size);
rmSetWorldCircleConstraint(false);
rmSetSeaLevel(0);
rmSetMapElevationParameters(cElevTurbulence, 0.06, 4, 0.4, 3);
rmTerrainInitialize("grass", 0);
rmSetMapType("pampas");
rmSetMapType("water");
rmSetLightingSet(lightingSet);
rmSetWindMagnitude(2);
chooseMercs();
rmDefineClass("classForest");
int classIsland = rmDefineClass("Island");
int classPatch = rmDefineClass("patch");
rmDefineClass("classCliff");
rmDefineClass("grass");

int avoidIslandMin=rmCreateClassDistanceConstraint("avoid island min", classIsland, 4.0);
int avoidIslandShort=rmCreateClassDistanceConstraint("avoid island short", classIsland, 8.0);
int avoidIsland=rmCreateClassDistanceConstraint("avoid island", classIsland, 12.0);
int avoidPatch = rmCreateClassDistanceConstraint("patch avoid patch", rmClassID("patch"), 12.0);
int avoidCoin = rmCreateTypeDistanceConstraint("avoid gold", "mine", 6);
int avoidAll = rmCreateTypeDistanceConstraint("avoid all", "all", 6);
int avoidAllLarge = rmCreateTypeDistanceConstraint("avoid all large", "all", 10);
int forestConstraint = -1;
if (rmGetIsTreaty() == true)
	forestConstraint = rmCreateClassDistanceConstraint("forest vs. forest", rmClassID("classForest"), 18);
else
	forestConstraint = rmCreateClassDistanceConstraint("forest vs. forest", rmClassID("classForest"), 25);
int forestConstraintSmall = rmCreateClassDistanceConstraint("forest vs. forest small", rmClassID("classForest"), 15);
int avoidTownCenter1 = rmCreateTypeDistanceConstraint("avoid Town Center1", "townCenter", 27);
int avoidTownCenterFar = rmCreateTypeDistanceConstraint("avoid Town Center far", "townCenter", 50);
int avoidLand = rmCreateTerrainDistanceConstraint("avoid land ", "Land", true, 12);
int avoidWater = rmCreateTerrainDistanceConstraint("avoid water ", "water", true, 5);
	int avoidTradeRoute = rmCreateTradeRouteDistanceConstraint("trade route", 8.0);
	int avoidTradeRouteShort = rmCreateTradeRouteDistanceConstraint("trade route short", 4.0);
	int avoidTradeRouteMin = rmCreateTradeRouteDistanceConstraint("trade route min", 1.0);
	int avoidTradeRouteSocket = rmCreateTypeDistanceConstraint("avoid trade route socket", "socketTradeRoute", 8.0);
	int avoidTradeRouteSocketShort = rmCreateTypeDistanceConstraint("avoid trade route socket short", "socketTradeRoute", 4.0);
	int avoidTradeRouteSocketMin = rmCreateTypeDistanceConstraint("avoid trade route socket min", "socketTradeRoute", 2.0);

rmSetStatusText("", 0.10);

int terrainMix = rmCreateArea("Terrain Mix");
rmSetAreaLocation(terrainMix, 0.5, 0.5);
rmSetAreaCoherence(terrainMix, 0.1);
rmSetAreaBaseHeight(terrainMix, 3.5);
rmSetAreaSize(terrainMix, 1, 1);
rmSetAreaMix(terrainMix, baseTerrainType);
rmBuildArea(terrainMix);
int terrainMix2 = rmCreateArea("Terrain Mix2");
rmSetAreaLocation(terrainMix2, 0.2, 0.5);
rmAddAreaInfluenceSegment(terrainMix2, 0.2, 0, 0.2, 1);
rmSetAreaCoherence(terrainMix2, 0.8);
rmSetAreaSize(terrainMix2, 0.5, 0.5);
rmSetAreaMix(terrainMix2, "araucania_grass_a");
rmBuildArea(terrainMix2);
int avoidGreenArea = rmCreateAreaDistanceConstraint("avoid grean area", terrainMix2, 25);
int stayGreenArea = rmCreateAreaMaxDistanceConstraint("stay grean area", terrainMix2, 0);
int WaterTop = rmCreateArea("Water Top");
rmSetAreaLocation(WaterTop, 0.9, 0.5);
rmAddAreaInfluenceSegment(WaterTop, 0.9, 0, 0.9, 1);
rmSetAreaCoherence(WaterTop, 0.75);
rmSetAreaSize(WaterTop, 0.27, 0.27);
rmSetAreaWaterType(WaterTop, waterType);
rmSetAreaEdgeFilling(WaterTop, 1);
rmSetAreaObeyWorldCircleConstraint(WaterTop, false);
rmBuildArea(WaterTop);
int stayInWater = rmCreateAreaMaxDistanceConstraint("stay in water", WaterTop, 0);

int cliffBaseID = rmCreateArea("cliff base");
rmSetAreaLocation(cliffBaseID, 0.3, 0.5);
rmAddAreaInfluenceSegment(cliffBaseID, 0.14, 0.5, 0.35, 0.5);
rmSetAreaTerrainType(cliffBaseID, impDirt);
rmSetAreaSize(cliffBaseID, 0.05);
rmSetAreaCoherence(cliffBaseID, 1.00);
rmAddAreaToClass(cliffBaseID, rmClassID("classCliff"));
rmSetAreaWarnFailure(cliffBaseID, false);
if (cNumberTeams == 2 && rmGetIsTreaty() == false)
	rmBuildArea(cliffBaseID);

int cliffID = rmCreateArea("cliff top");
rmSetAreaLocation(cliffID, 0.3, 0.5);
if (cNumberNonGaiaPlayers == 2 && rmGetIsTreaty() == true)
	rmAddAreaInfluenceSegment(cliffID, 0.00, 0.5, 0.30, 0.5);
else
	rmAddAreaInfluenceSegment(cliffID, 0.175, 0.5, 0.35, 0.5);
rmSetAreaSize(cliffID, 0.02);
rmSetAreaCoherence(cliffID, 0.85);
rmSetAreaSmoothDistance(cliffID, 4);
rmSetAreaHeightBlend(cliffID, 6);
rmSetAreaCliffHeight(cliffID, 8, 2, 0);
rmSetAreaCliffType(cliffID, cliffType);
rmSetAreaCliffEdge(cliffID, 1, 1, 0, 1, 0);
rmAddAreaToClass(cliffID, rmClassID("classCliff"));
rmSetAreaCliffPainting(cliffID, true, true, true, 1, true);
rmSetAreaWarnFailure(cliffID, false);
rmBuildArea(cliffID);

int stayCliff = rmCreateAreaMaxDistanceConstraint("stay near cliff", cliffID, 4);

rmSetStatusText("", 0.20);

if ((rmRandFloat(0, 1) > 0.5)) {
	int NorthIsland = rmCreateArea("north island");
	rmSetAreaLocation(NorthIsland, 0.9, 0.5);
	rmSetAreaSize(NorthIsland, 0.016, 0.016);
	rmSetAreaSmoothDistance(NorthIsland, 7);
	rmSetAreaMix(NorthIsland, "araucania_grass_b");
	rmAddAreaToClass(NorthIsland, classIsland);
	rmSetAreaElevationType(NorthIsland, cElevTurbulence);
	rmSetAreaElevationVariation(NorthIsland, 2);
	rmSetAreaBaseHeight(NorthIsland, 0);
	rmSetAreaElevationMinFrequency(NorthIsland, 0.09);
	rmSetAreaElevationOctaves(NorthIsland, 3);
	rmSetAreaElevationPersistence(NorthIsland, 0.2);
	rmSetAreaElevationNoiseBias(NorthIsland, 1);
	rmSetAreaCoherence(NorthIsland, 0.6);
	rmSetAreaObeyWorldCircleConstraint(NorthIsland, true);
	rmSetAreaLocation(NorthIsland, 0.87, 0.5);
	rmBuildArea(NorthIsland);
	int islandCrateID = rmCreateObjectDef("island crates");
//	rmAddObjectDefItem(islandCrateID, "CrateofWood", 1, 4);
//	rmAddObjectDefItem(islandCrateID, "CrateofCoin", 1, 4);
	rmAddObjectDefItem(islandCrateID, treeType, 5, 3);
	rmAddObjectDefConstraint(islandCrateID, avoidWater);
	rmPlaceObjectDefInArea(islandCrateID, 0, rmAreaID("north island"), 1);
}
else {
	int NorthIsland1 = rmCreateArea("north island1");
	rmSetAreaLocation(NorthIsland1, 0.9, 0.5);
	rmSetAreaSize(NorthIsland1, 0.011, 0.011);
	rmSetAreaSmoothDistance(NorthIsland1, 3);
	rmSetAreaMix(NorthIsland1, "araucania_grass_b");
	rmAddAreaToClass(NorthIsland1, classIsland);
	rmSetAreaElevationType(NorthIsland1, cElevTurbulence);
	rmSetAreaElevationVariation(NorthIsland1, 2);
	rmSetAreaBaseHeight(NorthIsland1, 0);
	rmSetAreaElevationMinFrequency(NorthIsland1, 0.09);
	rmSetAreaElevationOctaves(NorthIsland1, 3);
	rmSetAreaElevationPersistence(NorthIsland1, 0.2);
	rmSetAreaElevationNoiseBias(NorthIsland1, 1);
	rmSetAreaCoherence(NorthIsland1, 0.6);
	rmSetAreaObeyWorldCircleConstraint(NorthIsland1, true);
	rmSetAreaLocation(NorthIsland1, 0.87, 0.7);
	rmBuildArea(NorthIsland1);
	int NorthIsland2 = rmCreateArea("north island2");
	rmSetAreaLocation(NorthIsland2, 0.9, 0.5);
	rmSetAreaSize(NorthIsland2, 0.011, 0.011);
	rmSetAreaSmoothDistance(NorthIsland2, 3);
	rmSetAreaMix(NorthIsland2, "araucania_grass_b");
	rmAddAreaToClass(NorthIsland2, classIsland);
	rmSetAreaElevationType(NorthIsland2, cElevTurbulence);
	rmSetAreaElevationVariation(NorthIsland2, 2);
	rmSetAreaBaseHeight(NorthIsland2, 0);
	rmSetAreaElevationMinFrequency(NorthIsland2, 0.09);
	rmSetAreaElevationOctaves(NorthIsland2, 3);
	rmSetAreaElevationPersistence(NorthIsland2, 0.2);
	rmSetAreaElevationNoiseBias(NorthIsland2, 1);
	rmSetAreaCoherence(NorthIsland2, 0.6);
	rmSetAreaObeyWorldCircleConstraint(NorthIsland2, true);
	rmSetAreaLocation(NorthIsland2, 0.87, 0.3);
	rmBuildArea(NorthIsland2);
	int islandCrateID2 = rmCreateObjectDef("island crates");
//	rmAddObjectDefItem(islandCrateID2, "CrateofWood", 1, 4);
	rmAddObjectDefItem(islandCrateID2, "TreeAraucania", 3, 3);
	rmPlaceObjectDefInArea(islandCrateID2, 0, rmAreaID("north island1"), 1);
	rmPlaceObjectDefInArea(islandCrateID2, 0, rmAreaID("north island2"), 1); 
}

int avoidCliff = rmCreateAreaDistanceConstraint("avoid cliff north", cliffID, 5);
int avoidCliffFar = rmCreateAreaDistanceConstraint("avoid cliff north far", cliffBaseID, 4);
int tradeRouteID1 = rmCreateTradeRoute();
int socketID1 = rmCreateObjectDef("sockets to dock Trade Posts1");
rmSetObjectDefTradeRouteID(socketID1, tradeRouteID1);
rmAddObjectDefItem(socketID1, "SocketTradeRoute", 1, 0);
rmSetObjectDefAllowOverlap(socketID1, true);
rmSetObjectDefMinDistance(socketID1, 2);
rmSetObjectDefMaxDistance(socketID1, 8);
rmAddTradeRouteWaypoint(tradeRouteID1, 0.59, 0);
rmAddTradeRouteWaypoint(tradeRouteID1, 0.59, 0.5);
rmAddTradeRouteWaypoint(tradeRouteID1, 0.59, 1);

float tpLocA = 0.00;
float tpLocB = 0.00;
if (rmGetIsTreaty() == true) {
	tpLocA = 0.20;
	tpLocB = 0.80;
	}
else {
	tpLocA = 0.10-0.005*cNumberNonGaiaPlayers;
	tpLocB = 0.90+0.005*cNumberNonGaiaPlayers;
	}

bool placedTradeRoute1 = rmBuildTradeRoute(tradeRouteID1, "dirt_trail");
vector socketLoc = rmGetTradeRouteWayPoint(tradeRouteID1, tpLocA);
rmPlaceObjectDefAtPoint(socketID1, 0, socketLoc);
socketLoc=rmGetTradeRouteWayPoint(tradeRouteID1, 0.5);
rmPlaceObjectDefAtPoint(socketID1, 0, socketLoc);
socketLoc=rmGetTradeRouteWayPoint(tradeRouteID1, tpLocB);
rmPlaceObjectDefAtPoint(socketID1, 0, socketLoc);
int teamZeroCount = rmGetNumberPlayersOnTeam(0);
int teamOneCount = rmGetNumberPlayersOnTeam(1);
teamZeroCount=(PlayerNum / 2);
teamOneCount=(PlayerNum / 2);
if (cNumberTeams > 2) {
	rmPlacePlayer(1, 0.25, 0.8);
	rmPlacePlayer(2, 0.25, 0.2);
	rmPlacePlayer(3, 0.65, 0.75);
	rmPlacePlayer(4, 0.65, 0.25);
	rmPlacePlayer(5, 0.45, 0.9);
	rmPlacePlayer(6, 0.45, 0.1);
	rmPlacePlayer(7, 0.12, 0.65);
	rmPlacePlayer(8, 0.12, 0.35);
}
else if ((cNumberNonGaiaPlayers <= 2)) {
	rmSetPlacementTeam(0);
	rmPlacePlayersLine(0.2, 0.78, 0.38, 0.78, 0, 0);
	rmSetPlacementTeam(1);
	rmPlacePlayersLine(0.2, 0.22, 0.38, 0.22, 0, 0);
}
else if ((cNumberNonGaiaPlayers <= 4 && rmGetIsTreaty() == false)) {
	rmSetPlacementTeam(0);
	rmPlacePlayersLine(0.18, 0.78, 0.38, 0.78, 0, 0);
	rmSetPlacementTeam(1);
	rmPlacePlayersLine(0.18, 0.22, 0.38, 0.22, 0, 0);
}
else if ((cNumberNonGaiaPlayers <= 4 && rmGetIsTreaty() == true)) {
	rmSetPlacementTeam(0);
	rmPlacePlayersLine(0.185, 0.78, 0.475, 0.78, 0, 0);
	rmSetPlacementTeam(1);
	rmPlacePlayersLine(0.185, 0.22, 0.475, 0.22, 0, 0);
}
else if (cNumberNonGaiaPlayers <= 6) {
	rmSetPlacementTeam(0);
	rmPlacePlayersLine(0.14, 0.78, 0.50, 0.81, 0, 0);
	rmSetPlacementTeam(1);
	rmPlacePlayersLine(0.14, 0.22, 0.50, 0.19, 0, 0); 
}
else {
	rmSetPlacementTeam(0);
	rmPlacePlayersLine(0.13, 0.80, 0.52, 0.85, 0, 0);
	rmSetPlacementTeam(1);
	rmPlacePlayersLine(0.13, 0.20, 0.52, 0.15, 0, 0); 
}

float xNatLocA = 0.00;
float yNatLocA = 0.00;
float xNatLocB = 0.00;
float yNatLocB = 0.00;
if (rmGetIsTreaty() == false || teamZeroCount != teamOneCount) {
	xNatLocA = 0.43;
	yNatLocA = 0.67;
	xNatLocB = 0.43;
	yNatLocB = 0.33;
	}
else {
	if (cNumberNonGaiaPlayers <= 4) {
		xNatLocA = 0.335;
		yNatLocA = 0.78;
		xNatLocB = 0.335;
		yNatLocB = 0.22;
		}
	else {
		xNatLocA = 0.25;
		yNatLocA = 0.67;
		xNatLocB = 0.25;
		yNatLocB = 0.33;
		}
	}

rmSetSubCiv(0, subCiv);
int nativeID1 = rmCreateGrouping("Jesuit village 1", (nativeVillage + 3));
rmSetGroupingMinDistance(nativeID1, 0);
rmSetGroupingMaxDistance(nativeID1, 0);
rmPlaceGroupingAtLoc(nativeID1, 0, xNatLocA, yNatLocA);
rmPlaceGroupingAtLoc(nativeID1, 0, xNatLocB, yNatLocB);
for (i=1;  < numPlayer) {
	int id1 = rmCreateArea(("For players" + i));
	rmSetPlayerArea(i, id1);
	rmSetAreaSize(id1, rmAreaTilesToFraction(375));
	rmSetAreaLocPlayer(id1, i);
	rmSetAreaCoherence(id1, 0.7);
	rmSetAreaMix(id1, "araucania_dirt_b");
	rmSetAreaSmoothDistance(id1, 1);
	rmSetAreaWarnFailure(id1, false);
	rmBuildArea(id1);
}

rmSetStatusText("", 0.30);

	// 1st patches
	for (i=0; < 20*PlayerNum)
	{
		int patchID = rmCreateArea("first patch"+i);
		rmSetAreaWarnFailure(patchID, false);
		rmSetAreaObeyWorldCircleConstraint(patchID, true);
		rmSetAreaSize(patchID, rmAreaTilesToFraction(10), rmAreaTilesToFraction(20));
//		rmSetAreaTerrainType(patchID, "");
//		rmSetAreaMix(patchID, "testmix"); 
		rmSetAreaMix(patchID, "araucania_dirt_b"); 
		rmAddAreaToClass(patchID, rmClassID("patch"));
		rmSetAreaMinBlobs(patchID, 0);
		rmSetAreaMaxBlobs(patchID, 1);
		rmSetAreaMinBlobDistance(patchID, 1.0);
		rmSetAreaMaxBlobDistance(patchID, 4.0);
		rmSetAreaCoherence(patchID, 0.0);
		rmAddAreaConstraint(patchID, avoidPatch);
		rmAddAreaConstraint(patchID, stayGreenArea);
		rmAddAreaConstraint(patchID, avoidCliffFar);
		rmBuildArea(patchID); 
	}
	
	// 2nd patches
	for (i=0; < 6+2*PlayerNum)
	{
		int patch2ID = rmCreateArea("second patch"+i);
		rmSetAreaWarnFailure(patch2ID, false);
		rmSetAreaObeyWorldCircleConstraint(patch2ID, true);
		rmSetAreaSize(patch2ID, rmAreaTilesToFraction(10), rmAreaTilesToFraction(20));
//		rmSetAreaTerrainType(patch2ID, "");
//		rmSetAreaMix(patch2ID, "testmix"); 
		rmSetAreaMix(patch2ID, "araucania_north_grass_a"); 
		rmAddAreaToClass(patch2ID, rmClassID("patch"));
		rmSetAreaMinBlobs(patch2ID, 1);
		rmSetAreaMaxBlobs(patch2ID, 2);
		rmSetAreaMinBlobDistance(patch2ID, 1.0);
		rmSetAreaMaxBlobDistance(patch2ID, 10.0);
		rmSetAreaCoherence(patch2ID, 0.0);
		rmAddAreaConstraint(patch2ID, avoidPatch);
		rmAddAreaConstraint(patch2ID, stayCliff);	
		rmBuildArea(patch2ID); 
	}

int startingUnits = rmCreateStartingUnitsObjectDef(5);
rmSetObjectDefMinDistance(startingUnits, 0);
rmSetObjectDefMaxDistance(startingUnits, 0);
int startingTCID = rmCreateObjectDef("startingTC");
if (rmGetNomadStart()) {
	rmAddObjectDefItem(startingTCID, "CoveredWagon", 1, 0);
}
else {
	rmAddObjectDefItem(startingTCID, "TownCenter", 1, 0); 
}

rmSetObjectDefMinDistance(startingTCID, 0);
rmSetObjectDefMaxDistance(startingTCID, 0);
int playergoldID = rmCreateObjectDef("player mine");
rmAddObjectDefItem(playergoldID, mineType, 1, 0);
rmSetObjectDefMinDistance(playergoldID, 14);
rmSetObjectDefMaxDistance(playergoldID, 14);
rmAddObjectDefConstraint(playergoldID, avoidAll);
int startingTrees = rmCreateObjectDef("Starting trees");
if (rmGetIsTreaty() == true && cNumberNonGaiaPlayers == 2)
	rmAddObjectDefItem(startingTrees, treeType, 9, 3);
else
	rmAddObjectDefItem(startingTrees, treeType, 3, 8);
rmSetObjectDefMinDistance(startingTrees, 14);
rmSetObjectDefMaxDistance(startingTrees, 18);
rmAddObjectDefConstraint(startingTrees, avoidAll);
int startingHunting = rmCreateObjectDef("Starting hunting close");
if (rmGetIsTreaty() == true)
	rmAddObjectDefItem(startingHunting, "Capybara", 12, 6);
else
	rmAddObjectDefItem(startingHunting, "Capybara", 7, 6);
rmSetObjectDefMinDistance(startingHunting, 14);
rmSetObjectDefMaxDistance(startingHunting, 14);
rmSetObjectDefCreateHerd(startingHunting, true);
rmAddObjectDefConstraint(startingHunting, avoidAll);
int playerCrateID = rmCreateObjectDef("bonus starting crates");
rmAddObjectDefItem(playerCrateID, "crateOfWood", 1, 4);
rmSetObjectDefMinDistance(playerCrateID, 10);
rmSetObjectDefMaxDistance(playerCrateID, 12);
rmAddObjectDefConstraint(playerCrateID, avoidAll);
int playerNuggetID = rmCreateObjectDef("player nugget");
rmAddObjectDefItem(playerNuggetID, "nugget", 1, 0);
rmSetObjectDefMinDistance(playerNuggetID, 25);
rmSetObjectDefMaxDistance(playerNuggetID, 30);
rmAddObjectDefConstraint(playerNuggetID, avoidAll);
int colonyShipID = rmCreateObjectDef("colony ship ");
rmAddObjectDefItem(colonyShipID, "HomeCityWaterSpawnFlag", 1, 1);
rmSetObjectDefMinDistance(colonyShipID, rmXFractionToMeters(0.01));
rmSetObjectDefMaxDistance(colonyShipID, rmXFractionToMeters(0.05));
rmAddObjectDefConstraint(colonyShipID, avoidAll);
rmAddObjectDefConstraint(colonyShipID, avoidLand);
int StartBerriesID = rmCreateObjectDef("starting berries");
rmAddObjectDefItem(StartBerriesID, "berrybush", 3, 3);
rmSetObjectDefMinDistance(StartBerriesID, 8);
rmSetObjectDefMaxDistance(StartBerriesID, 12);
rmAddObjectDefConstraint(StartBerriesID, avoidAll);
for (i=1;  <= PlayerNum) {
	rmPlaceObjectDefAtLoc(startingTCID, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));

	rmPlaceObjectDefAtLoc(startingUnits, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	rmPlaceObjectDefAtLoc(playerCrateID, 0, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	rmPlaceObjectDefAtLoc(playergoldID, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	rmPlaceObjectDefAtLoc(startingTrees, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	rmPlaceObjectDefAtLoc(startingTrees, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	rmPlaceObjectDefAtLoc(startingTrees, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	if (rmGetIsTreaty() == true) {
		rmPlaceObjectDefAtLoc(startingTrees, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
		rmPlaceObjectDefAtLoc(startingTrees, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
		rmPlaceObjectDefAtLoc(startingTrees, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
		}
	rmPlaceObjectDefAtLoc(startingHunting, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	if (rmGetIsTreaty() == false)
		rmPlaceObjectDefAtLoc(StartBerriesID, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	rmSetNuggetDifficulty(1, 1);
	rmPlaceObjectDefAtLoc(playerNuggetID, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	rmPlaceObjectDefAtLoc(playerNuggetID, i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	rmPlaceObjectDefAtLoc(colonyShipID, i, 0.80, rmPlayerLocZFraction(i));

	if(ypIsAsian(i) && rmGetNomadStart() == false)
	{
		if (rmGetIsTreaty() == false)
			rmPlaceObjectDefAtLoc(ypMonasteryBuilder(i), i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
		else
			rmPlaceObjectDefAtLoc(ypMonasteryBuilder(i,1), i, rmPlayerLocXFraction(i), rmPlayerLocZFraction(i));
	}
}

rmSetStatusText("", 0.40);

int silverID = rmCreateObjectDef("mines");
rmAddObjectDefItem(silverID, mineType, 1, 0);
rmSetObjectDefMinDistance(silverID, 0);
rmSetObjectDefMaxDistance(silverID, 10);
rmAddObjectDefConstraint(silverID, avoidTradeRouteMin);
rmAddObjectDefConstraint(silverID, avoidTradeRouteSocketMin);
rmAddObjectDefConstraint(silverID, avoidCliffFar);
rmAddObjectDefConstraint(silverID, avoidIsland);
int avoidHunt = rmCreateTypeDistanceConstraint("avoid the hunt1", huntType, 50);
int avoidMines = rmCreateTypeDistanceConstraint("avoid the mines", "gold", 55);
int herdID = rmCreateObjectDef("herd herd");
if (rmGetIsTreaty() == true)
	rmAddObjectDefItem(herdID, huntType, 12, 6);
else
	rmAddObjectDefItem(herdID, huntType, rmRandInt(10, 11), 6);
rmSetObjectDefMinDistance(herdID, 0);
rmSetObjectDefMaxDistance(herdID, 2);
rmAddObjectDefConstraint(herdID, avoidAll);
rmAddObjectDefConstraint(herdID, avoidIsland);
rmAddObjectDefConstraint(herdID, avoidCliff);
rmSetObjectDefCreateHerd(herdID, true);
if ((PlayerNum == 2)) {
	rmPlaceObjectDefAtLoc(silverID, 0, 0.12, 0.90);
	rmPlaceObjectDefAtLoc(silverID, 0, 0.12, 0.10);
	rmPlaceObjectDefAtLoc(herdID, 0, 0.10, 0.16, 1);
	rmPlaceObjectDefAtLoc(herdID, 0, 0.10, 0.84, 1);
	if ((rmRandFloat(0, 1) > 0.5))
	{
		rmPlaceObjectDefAtLoc(silverID, 0, 0.65, 0.2);
		if (rmGetIsTreaty() == false) {
			rmPlaceObjectDefAtLoc(silverID, 0, 0.65, 0.5);
			rmPlaceObjectDefAtLoc(silverID, 0, 0.05, 0.5);
			rmPlaceObjectDefAtLoc(herdID, 0, 0.42, 0.5);
			}
		else {
			rmPlaceObjectDefAtLoc(silverID, 0, 0.48, 0.7);
			rmPlaceObjectDefAtLoc(silverID, 0, 0.48, 0.3);
			rmPlaceObjectDefAtLoc(silverID, 0, 0.05, 0.65);
			rmPlaceObjectDefAtLoc(silverID, 0, 0.05, 0.35);
			rmPlaceObjectDefAtLoc(herdID, 0, 0.40, 0.70);
			rmPlaceObjectDefAtLoc(herdID, 0, 0.40, 0.30);
			}
		rmPlaceObjectDefAtLoc(silverID, 0, 0.65, 0.8);
		rmPlaceObjectDefAtLoc(silverID, 0, 0.35, 0.25);
		rmPlaceObjectDefAtLoc(silverID, 0, 0.35, 0.75);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.30, 0.08);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.30, 0.92);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.42, 0.2, 1);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.42, 0.8, 1);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.60, 0.3, 1);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.60, 0.7, 1);
	}
	else
	{
		rmPlaceObjectDefAtLoc(silverID, 0, 0.65, 0.3);
		rmPlaceObjectDefAtLoc(silverID, 0, 0.65, 0.7);
		if (rmGetIsTreaty() == false) {
			rmPlaceObjectDefAtLoc(silverID, 0, 0.42, 0.5);
			rmPlaceObjectDefAtLoc(herdID, 0, 0.05, 0.5, 1); 
			}
		else {
			rmPlaceObjectDefAtLoc(silverID, 0, 0.42, 0.65);
			rmPlaceObjectDefAtLoc(silverID, 0, 0.42, 0.35);
			rmPlaceObjectDefAtLoc(herdID, 0, 0.05, 0.65, 1); 
			rmPlaceObjectDefAtLoc(herdID, 0, 0.05, 0.35, 1); 
			}
		rmPlaceObjectDefAtLoc(silverID, 0, 0.38, 0.08);
		rmPlaceObjectDefAtLoc(silverID, 0, 0.38, 0.92);
		rmPlaceObjectDefAtLoc(silverID, 0, 0.07, 0.62);
		rmPlaceObjectDefAtLoc(silverID, 0, 0.07, 0.38);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.45, 0.2, 1);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.45, 0.8, 1);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.60, 0.05, 1);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.60, 0.95, 1);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.33, 0.3, 1);
		rmPlaceObjectDefAtLoc(herdID, 0, 0.33, 0.7, 1);
	}
}
else {
	int staySouth = rmCreatePieConstraint("Stay South", 0.47, 0.47, rmXFractionToMeters(0), rmXFractionToMeters(0.5), rmDegreesToRadians(92), rmDegreesToRadians(268));
	int stayNorth = rmCreatePieConstraint("Stay North", 0.53, 0.53, rmXFractionToMeters(0), rmXFractionToMeters(0.5), rmDegreesToRadians(272), rmDegreesToRadians(88));
	for (i=0;  < ((PlayerNum / 2) * 4)) {
	int silverID1 = rmCreateObjectDef(("mines team1x" + i));
	rmAddObjectDefItem(silverID1, mineType, 1, 0);
	rmSetObjectDefMinDistance(silverID1, 0);
	rmAddObjectDefConstraint(silverID1, avoidMines);
	rmAddObjectDefConstraint(silverID1, avoidTownCenterFar);
	rmAddObjectDefConstraint(silverID1, avoidWater);
	rmAddObjectDefConstraint(silverID1, avoidCliff);
	rmAddObjectDefConstraint(silverID1, stayNorth);
	rmAddObjectDefConstraint(silverID1, avoidTradeRouteSocketMin);
	rmAddObjectDefConstraint(silverID1, avoidIsland);
	rmAddObjectDefConstraint(silverID1, avoidTradeRouteMin);
	rmSetObjectDefMaxDistance(silverID1, rmXFractionToMeters(0.5));
	rmPlaceObjectDefAtLoc(silverID1, 0, 0.5, 0.5, 1);
	int herdID1 = rmCreateObjectDef(("herd herd team1x" + i));
	rmAddObjectDefItem(herdID1, huntType, rmRandInt(10, 11), 6);
	rmSetObjectDefMinDistance(herdID1, 0);
	rmAddObjectDefConstraint(herdID1, avoidAll);
	rmAddObjectDefConstraint(herdID1, avoidCliff);
	rmSetObjectDefCreateHerd(herdID1, true);
	rmAddObjectDefConstraint(herdID1, avoidIsland);
	rmAddObjectDefConstraint(herdID1, avoidHunt);
	rmAddObjectDefConstraint(herdID1, avoidTradeRouteSocketShort);
	rmAddObjectDefConstraint(herdID1, avoidTownCenterFar);
	rmAddObjectDefConstraint(herdID1, avoidWater);
	rmAddObjectDefConstraint(herdID1, stayNorth);
	rmSetObjectDefMaxDistance(herdID1, rmXFractionToMeters(0.5));
	rmPlaceObjectDefAtLoc(herdID1, 0, 0.5, 0.5, 1);
}
	for (i=0;  < ((PlayerNum / 2) * 4)) {
	int silverID2 = rmCreateObjectDef(("mines team2x" + i));
	rmAddObjectDefItem(silverID2, mineType, 1, 0);
	rmSetObjectDefMinDistance(silverID2, 0);
	rmAddObjectDefConstraint(silverID2, avoidMines);
	rmAddObjectDefConstraint(silverID2, avoidTownCenterFar);
	rmAddObjectDefConstraint(silverID2, avoidWater);
	rmAddObjectDefConstraint(silverID2, avoidCliff);
	rmAddObjectDefConstraint(silverID2, avoidIsland);
	rmAddObjectDefConstraint(silverID2, staySouth);
	rmAddObjectDefConstraint(silverID2, avoidTradeRouteSocketMin);
	rmAddObjectDefConstraint(silverID2, avoidTradeRouteMin);
	rmSetObjectDefMaxDistance(silverID2, rmXFractionToMeters(0.5));
	rmPlaceObjectDefAtLoc(silverID2, 0, 0.5, 0.5, 1);
	int herdID2 = rmCreateObjectDef(("herd herd team2x" + i));
	rmAddObjectDefItem(herdID2, huntType, rmRandInt(10, 11), 6);
	rmSetObjectDefMinDistance(herdID2, 0);
	rmAddObjectDefConstraint(herdID2, avoidAll);
	rmAddObjectDefConstraint(herdID2, avoidCliff);
	rmSetObjectDefCreateHerd(herdID2, true);
	rmAddObjectDefConstraint(herdID2, avoidHunt);
	rmAddObjectDefConstraint(herdID2, avoidIsland);
	rmAddObjectDefConstraint(herdID2, avoidTownCenterFar);
	rmAddObjectDefConstraint(herdID2, staySouth);
	rmAddObjectDefConstraint(herdID2, avoidWater);
	rmSetObjectDefMaxDistance(herdID2, rmXFractionToMeters(0.5));
	rmPlaceObjectDefAtLoc(herdID2, 0, 0.5, 0.5, 1);
} 
}

rmSetStatusText("", 0.50);

float forestPass = (4+4 * numPlayer);
if (rmGetIsTreaty() == true)
	forestPass = 8+8*numPlayer;

float forestFailCount = 0;
for (i=0;  < forestPass) {
	int forestNorth = rmCreateArea(("Forest north " + i), terrainMix2);
	rmSetAreaSize(forestNorth, rmAreaTilesToFraction(100));
	rmSetAreaForestType(forestNorth, forestType);
	if (rmGetIsTreaty() == true) {
		rmSetAreaForestDensity(forestNorth, 0.99);
		rmSetAreaForestClumpiness(forestNorth, 0.99);
		}
	else {
		rmSetAreaForestDensity(forestNorth, 0.65);
		rmSetAreaForestClumpiness(forestNorth, 0.5);
		}
	rmSetAreaForestUnderbrush(forestNorth, 0.6);
	rmSetAreaCoherence(forestNorth, 0.8);
//	rmSetAreaSmoothDistance(forestNorth, 10);
	rmAddAreaToClass(forestNorth, rmClassID("classForest"));
	rmAddAreaConstraint(forestNorth, forestConstraint);
	rmAddAreaConstraint(forestNorth, avoidCoin);
	rmAddAreaConstraint(forestNorth, avoidAllLarge);
	rmAddAreaConstraint(forestNorth, avoidTownCenter1);
	rmAddAreaConstraint(forestNorth, avoidTradeRouteSocket);
	if (rmGetIsTreaty() == true)
		rmAddAreaConstraint(forestNorth, avoidCliff);
	else
		rmAddAreaConstraint(forestNorth, avoidCliffFar);
	if ((rmBuildArea(forestNorth) == false)) {
	forestFailCount++;
	if ((forestFailCount == 6)) {
	break;
}

}
forestFailCount=0;
}

rmSetStatusText("", 0.60);

forestPass=(4+4 * numPlayer);
forestFailCount=0;
for (i=0;  < forestPass) {
	int coastalForest = rmCreateArea(("Coastal forest " + i));
	rmSetAreaSize(coastalForest, rmAreaTilesToFraction(150), rmAreaTilesToFraction(200));
	rmSetAreaForestType(coastalForest, forestType);
	rmSetAreaForestDensity(coastalForest, 0.35);
	rmSetAreaForestClumpiness(coastalForest, 0.2);
	rmSetAreaForestUnderbrush(coastalForest, 0.4);
	rmSetAreaCoherence(coastalForest, 0.8);
//	rmSetAreaSmoothDistance(coastalForest, 10);
	rmAddAreaToClass(coastalForest, rmClassID("classForest"));
	rmAddAreaConstraint(coastalForest, forestConstraintSmall);
	rmAddAreaConstraint(coastalForest, avoidCoin);
	rmAddAreaConstraint(coastalForest, avoidAllLarge);
	rmAddAreaConstraint(coastalForest, avoidTradeRouteSocket);
	rmAddAreaConstraint(coastalForest, avoidGreenArea);
	if ((rmBuildArea(coastalForest) == false)) {
	forestFailCount++;
	if ((forestFailCount == 200)) {
	break;
}

}
forestFailCount=0;
}

rmSetStatusText("", 0.70);

int fishVsFishID = rmCreateTypeDistanceConstraint("fish v fish", "fish", 20);
int whaleVsWhale = rmCreateTypeDistanceConstraint("whale v whale", "humpbackWhale", 40);
int fishLand = rmCreateTerrainDistanceConstraint("fish land", "land", true, 8);
for (i=0;  < ((PlayerNum * 2) + 1)) {
	int northWhales = rmCreateObjectDef((" North whales" + i));
	rmAddObjectDefItem(northWhales, "HumpbackWhale", 1, 0);
	rmSetObjectDefMinDistance(northWhales, 0);
	rmSetObjectDefMaxDistance(northWhales, 5);
	rmSetObjectDefMaxDistance(northWhales, rmXFractionToMeters(0.5));
	rmAddObjectDefConstraint(northWhales, fishLand);
	rmAddObjectDefConstraint(northWhales, avoidAll);
	rmAddObjectDefConstraint(northWhales, avoidIsland);
	rmAddObjectDefConstraint(northWhales, whaleVsWhale);
	rmPlaceObjectDefAtLoc(northWhales, 0, 0.8, 0.5, 1);
}
for (i=0;  < (numPlayer * 5)) {
	int northFish = rmCreateObjectDef(("North fish" + i));
	rmAddObjectDefItem(northFish, "FishSardine", 1, 9);
	rmSetObjectDefMinDistance(northFish, 0);
	rmSetObjectDefMaxDistance(northFish, rmXFractionToMeters(0.5));
	rmAddObjectDefConstraint(northFish, avoidAll);
	rmAddObjectDefConstraint(northFish, fishLand);
	rmAddObjectDefConstraint(northFish, fishVsFishID);
	rmPlaceObjectDefAtLoc(northFish, 0, 0.8, 0.5, 1);
}

rmSetStatusText("", 0.80);

int avoidNugget = rmCreateTypeDistanceConstraint("nugget avoid nugget", "AbstractNugget", 44);
int nugget4ID = rmCreateObjectDef("nugget4");
rmAddObjectDefItem(nugget4ID, "Nugget", 1, 0);
rmSetObjectDefMinDistance(nugget4ID, 0);
rmSetObjectDefMaxDistance(nugget4ID, rmXFractionToMeters(0.3));
rmAddObjectDefConstraint(nugget4ID, avoidAllLarge);
rmAddObjectDefConstraint(nugget4ID, avoidNugget);
rmAddObjectDefConstraint(nugget4ID, avoidTownCenterFar);
rmAddObjectDefConstraint(nugget4ID, avoidCliff);
rmAddObjectDefConstraint(nugget4ID, avoidWater);
rmAddObjectDefConstraint(nugget4ID, avoidTradeRouteSocketShort);
rmAddObjectDefConstraint(nugget4ID, avoidTradeRouteShort);
rmAddObjectDefConstraint(nugget4ID, avoidGreenArea);
rmSetNuggetDifficulty(4, 4);
if (PlayerNum > 4 && rmGetIsTreaty() == false)
	rmPlaceObjectDefAtLoc(nugget4ID, 0, 0.8, 0.5, PlayerNum/2);

int nugget3ID = rmCreateObjectDef("nugget3");
rmAddObjectDefItem(nugget3ID, "Nugget", 1, 0);
rmSetObjectDefMinDistance(nugget3ID, 0);
rmSetObjectDefMaxDistance(nugget3ID, rmXFractionToMeters(0.4));
rmAddObjectDefConstraint(nugget3ID, avoidAllLarge);
rmAddObjectDefConstraint(nugget3ID, avoidNugget);
rmAddObjectDefConstraint(nugget3ID, avoidTownCenterFar);
rmAddObjectDefConstraint(nugget3ID, avoidCliff);
rmAddObjectDefConstraint(nugget3ID, avoidWater);
rmAddObjectDefConstraint(nugget3ID, avoidTradeRouteSocketShort);
rmAddObjectDefConstraint(nugget3ID, avoidTradeRouteShort);
rmSetNuggetDifficulty(3, 3);
if (PlayerNum == 4)
	rmAddObjectDefConstraint(nugget3ID, avoidGreenArea);
if (PlayerNum > 2)
	rmPlaceObjectDefAtLoc(nugget3ID, 0, 0.8, 0.5, PlayerNum);

int nugget2ID = rmCreateObjectDef("nugget2");
rmAddObjectDefItem(nugget2ID, "Nugget", 1, 0);
rmSetObjectDefMinDistance(nugget2ID, 0);
rmSetObjectDefMaxDistance(nugget2ID, rmXFractionToMeters(0.5));
rmAddObjectDefConstraint(nugget2ID, avoidAllLarge);
rmAddObjectDefConstraint(nugget2ID, avoidNugget);
rmAddObjectDefConstraint(nugget2ID, avoidTownCenterFar);
rmAddObjectDefConstraint(nugget2ID, avoidCliff);
rmAddObjectDefConstraint(nugget2ID, avoidWater);
rmAddObjectDefConstraint(nugget2ID, avoidTradeRouteSocketShort);
rmAddObjectDefConstraint(nugget2ID, avoidTradeRouteShort);
if (PlayerNum == 2)
	rmAddObjectDefConstraint(nugget2ID, avoidGreenArea);
rmSetNuggetDifficulty(2, 2);
rmPlaceObjectDefAtLoc(nugget2ID, 0, 0.7, 0.5, PlayerNum);

int nuggetID = rmCreateObjectDef("nugget");
rmAddObjectDefItem(nuggetID, "Nugget", 1, 0);
rmSetObjectDefMinDistance(nuggetID, 0);
rmSetObjectDefMaxDistance(nuggetID, rmXFractionToMeters(0.5));
rmAddObjectDefConstraint(nuggetID, avoidAllLarge);
rmAddObjectDefConstraint(nuggetID, avoidNugget);
rmAddObjectDefConstraint(nuggetID, avoidTownCenterFar);
rmAddObjectDefConstraint(nuggetID, avoidCliff);
rmAddObjectDefConstraint(nuggetID, avoidWater);
rmAddObjectDefConstraint(nuggetID, avoidTradeRouteSocketShort);
rmAddObjectDefConstraint(nuggetID, avoidTradeRouteShort);
rmAddObjectDefConstraint(nuggetID, stayGreenArea);
rmSetNuggetDifficulty(1, 1);
rmPlaceObjectDefAtLoc(nuggetID, 0, 0.1, 0.5, PlayerNum*3);

if (rmGetIsKOTH()) {
	float xLoc = 0.45;
	float yLoc = 0.5;
	float walk = 0.01;
	ypKingsHillPlacer(xLoc, yLoc, walk, 0);
	rmEchoInfo(("XLOC = " + xLoc));
	rmEchoInfo(("XLOC = " + yLoc));
}

rmSetStatusText("", 0.90);

int avoidEmbellishment = rmCreateClassDistanceConstraint("grass avoid grass", rmClassID("grass"), 12.0);
// Grass embellishments
int underbrushID = rmCreateObjectDef("grass props");
	rmAddObjectDefItem(underbrushID, "UnderbrushAraucania", rmRandInt(1,2), 3.0);
	rmSetObjectDefMinDistance(underbrushID, 0);
	rmSetObjectDefMaxDistance(underbrushID, rmXFractionToMeters(0.5));
	rmAddObjectDefToClass(underbrushID, rmClassID("grass"));
	rmAddObjectDefConstraint(underbrushID, avoidCliffFar);
	rmAddObjectDefConstraint(underbrushID, avoidEmbellishment);
	rmAddObjectDefConstraint(underbrushID, avoidAll);
	rmAddObjectDefConstraint(underbrushID, stayGreenArea);
	rmAddObjectDefConstraint(underbrushID, avoidTradeRouteSocketShort);
	rmPlaceObjectDefAtLoc(underbrushID, 0, 0.50, 0.50, 20+10*PlayerNum);

// Plateau embellishments
int PlateauunderbrushID = rmCreateObjectDef("plateau props");
	rmAddObjectDefItem(PlateauunderbrushID, "UnderbrushTexasGrass", rmRandInt(4,7), 10.0);
	rmSetObjectDefMinDistance(PlateauunderbrushID, 0);
	rmSetObjectDefMaxDistance(PlateauunderbrushID, rmXFractionToMeters(0.5));
	rmAddObjectDefToClass(PlateauunderbrushID, rmClassID("grass"));
	rmAddObjectDefConstraint(PlateauunderbrushID, stayCliff);
	rmAddObjectDefConstraint(PlateauunderbrushID, avoidAll);
	rmAddObjectDefConstraint(PlateauunderbrushID, avoidTradeRouteSocketShort);
	rmAddObjectDefConstraint(PlateauunderbrushID, avoidEmbellishment);
	rmPlaceObjectDefAtLoc(PlateauunderbrushID, 0, 0.50, 0.50, 4*PlayerNum);

rmSetStatusText("", 1);

}
